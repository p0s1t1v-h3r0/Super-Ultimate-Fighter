<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Super Ultimate Fighter</title>
<style>
body {
  background:#111;
  color:#eee;
  font-family: monospace;
  padding:20px;
}
button {
  margin:4px;
  padding:8px;
  background:#222;
  color:#eee;
  border:1px solid #555;
  cursor:pointer;
}
button:hover { background:#333; }
#log {
  border:1px solid #444;
  padding:10px;
  height:300px;
  overflow-y:auto;
  background:#000;
}
.stat {
  margin-bottom:6px;
}
</style>
</head>
<body>

<h1>Super Ultimate Fighter (Prototype)</h1>

<div class="stat" id="status"></div>
<div class="stat" id="range"></div>
<div class="stat" id="stance"></div>
<div class="stat" id="timer"></div>

<h3>Actions</h3>
<div id="actions"></div>

<h3>Combat Log</h3>
<div id="log"></div>

<script>
// ---------------- CORE DATA ----------------

const RANGES = ["Kickboxing", "Boxing", "Clinch", "Ground"];
const STANCES = ["Orthodox", "Southpaw"];

function createFighter(name) {
  return {
    name,
    stance: Math.random() > 0.5 ? "Orthodox" : "Southpaw",
    range: "Boxing",
    stamina: 100,
    balance: 100,
    delay: 0,
    buffs: {},
    limbs: {
      head: { skull: 100, face: 100 },
      torso: { chest: 100, liver: 100, solar: 100 },
      leftArm: { shoulder: 100, forearm: 100, hand: 100 },
      rightArm: { shoulder: 100, forearm: 100, hand: 100 },
      leftLeg: { thigh: 100, knee: 100, calf: 100 },
      rightLeg: { thigh: 100, knee: 100, calf: 100 }
    }
  };
}


let player = createFighter("You");
let enemy = createFighter("Opponent");

let turnStart = Date.now();
  function getPaceModifier(seconds) {
  if (seconds <= 10) {
    return { stamina: -2, delay: 0, accuracy: -0.05 };
  }
  if (seconds <= 20) {
    return { stamina: 0, delay: 1, accuracy: 0 };
  }
  return { stamina: -3, delay: 2, accuracy: +0.05 };
}
let logEl = document.getElementById("log");

// ---------------- UTILS ----------------
function applyPaceEffects(fighter, elapsed) {
  if (elapsed <= 10) {
    // fast, evasive
    fighter.stamina -= 6;
    fighter.delay += 0;
    return { accuracy: -0.1 };
  }

  if (elapsed <= 20) {
    // balanced
    fighter.stamina -= 3;
    fighter.delay += 1;
    return { accuracy: 0 };
  }

  // slow, deliberate
  fighter.stamina -= 1;
  fighter.delay += 2;
  return { accuracy: +0.15 };
}

  
function log(text) {
  logEl.innerHTML += text + "<br>";
  logEl.scrollTop = logEl.scrollHeight;
}

function injuryDesc(value, part) {
  if (value > 75) return `${part} looks fine.`;
  if (value > 50) return `${part} is bruised.`;
  if (value > 25) return `${part} looks painful to use.`;
  if (value > 10) return `${part} is badly compromised.`;
  return `${part} is nearly unusable.`;
}

function staminaDesc(v) {
  if (v > 75) return "Breathing steady.";
  if (v > 50) return "Breathing heavier.";
  if (v > 25) return "Labored breathing.";
  if (v > 10) return "Gasping for air.";
  return "On the verge of collapse.";
}

function painTell(fighter) {
  if (fighter.stamina < 30 && !fighter.buffs.conceal) {
    log(`${fighter.name}'s breathing is heavy.`);
  }
  if (fighter.balance < 40) {
    log(`${fighter.name} looks unsteady on their feet.`);
  }
}

function painTell(fighter) {
  if (fighter.stamina < 30 && !fighter.buffs.conceal) {
    log(`${fighter.name}'s breathing is heavy.`);
  }
  if (fighter.balance < 40) {
    log(`${fighter.name} looks unsteady on their feet.`);
  }
}
  function legStability(fighter) {
  const left = fighter.limbs.leftLeg.knee;
  const right = fighter.limbs.rightLeg.knee;
  const avg = (left + right) / 2;

  if (avg < 30) return -30;
  if (avg < 60) return -15;
  return 0;
}

  
// ---------------- MOVE DEFINITIONS ----------------

const MOVES = {
  jab: {
    name: "Jab",
    stamina: 5,
    accuracy: 0.8,
    damage: 8,
    delay: 1,
    range: ["Boxing"],
    risk: "Low"
  },
  cross: {
    name: "Cross",
    stamina: 8,
    accuracy: 0.7,
    damage: 14,
    delay: 2,
    range: ["Boxing"],
    risk: "Medium"
  },
  heavyKick: {
    name: "Heavy Kick",
    stamina: 15,
    accuracy: 0.5,
    damage: 25,
    delay: 4,
    balanceRisk: 15,
    range: ["Kickboxing"],
    risk: "High"
  },
  clinch: {
    name: "Enter Clinch",
    stamina: 10,
    accuracy: 0.7,
    delay: 2,
    rangeChange: "Clinch"
  },
  focus: {
    name: "Sharpen Focus",
    stamina: 6,
    delay: 1,
    buff: { accuracy: 0.15, turns: 3 }
  },
  pokerFace: {
    name: "Poker Face",
    stamina: 5,
    delay: 1,
    buff: { conceal: true, turns: 3 }
  },
  dodge: {
    name: "Dodge (Buffered)",
    stamina: 6,
    accuracy: 0.6,
    delay: 1,
    defensive: true
  }
};

let bufferedDefense = null;

function bufferDefense(moveKey) {
  bufferedDefense = moveKey;
  log(`You prepare to ${MOVES[moveKey].name.toLowerCase()}.`);
}  

// ---------------- TURN LOGIC ----------------


  
function performMove(attacker, defender, moveKey) {
  const move = MOVES[moveKey];
  attacker.stamina -= move.stamina;
  attacker.delay += move.delay;

  let acc = move.accuracy || 1;
  acc += attacker.tempAccuracyBonus || 0;


  if (attacker.buffs.accuracy) acc += attacker.buffs.accuracy.value;
  if (attacker.stamina < 30) acc -= 0.15;

  if (Math.random() < acc) {
if (move.damage) {
  const parts = Object.keys(defender.limbs);
  const hitPart = parts[Math.floor(Math.random() * parts.length)];

  const limb = defender.limbs[hitPart];
  const sub = Object.keys(limb)[Math.floor(Math.random() * Object.keys(limb).length)];
  limb[sub] -= move.damage;

  defender.balance += legStability(defender);

  log(`${attacker.name} lands a ${move.name} on the ${hitPart} (${sub}).`);

  if (!defender.buffs.conceal) {
    log(injuryDesc(limb[sub], `${hitPart} ${sub}`));
  }

  if (defender.balance <= 0) {
    log(`${defender.name} loses balance and falls!`);
    defender.delay += 2;
    defender.balance = 20;
  }
}


    if (move.rangeChange) {
      attacker.range = defender.range = move.rangeChange;
      log(`${attacker.name} forces the fight into the ${move.rangeChange}.`);
    }

    if (move.buff) {
      attacker.buffs[moveKey] = {
        value: move.buff.accuracy || null,
        turns: move.buff.turns,
        conceal: move.buff.conceal || false
      };
      log(`${attacker.name} looks composed and focused.`);
    }

  } else {
    log(`${attacker.name}'s ${move.name} misses.`);
    attacker.balance -= move.balanceRisk || 5;
  }

  painTell(attacker);
  painTell(defender);
}


function enemyTurn() {
  if (enemy.delay > 0) {
    enemy.delay--;
    log("Opponent regains footing.");
    return;
  }

  const choices = ["jab", "cross", "focus"];
  const choice = choices[Math.floor(Math.random() * choices.length)];
  performMove(enemy, player, choice);
}

// ---------------- UI ----------------

function updateUI() {
  document.getElementById("status").innerText =
    `You: ${staminaDesc(player.stamina)} | Balance feels ${player.balance > 50 ? "stable" : "shaky"}`;

  document.getElementById("range").innerText =
    `Range: ${player.range}`;

  document.getElementById("stance").innerText =
    `Stance: ${player.stance}`;

  const elapsed = Math.floor((Date.now() - turnStart) / 1000);
  document.getElementById("timer").innerText =
    `Turn Timer: ${elapsed}s`;

  const actions = document.getElementById("actions");
  actions.innerHTML = "";

Object.keys(MOVES).forEach(k => {
  const move = MOVES[k];
  const btn = document.createElement("button");
  btn.innerText = move.name;

  // ✅ BUFFERED DEFENSIVE MOVES
  if (move.defensive) {
    btn.onclick = () => {
      bufferDefense(k);
      updateUI();
    };
    actions.appendChild(btn);
    return;
  }

  // ✅ NORMAL MOVES
btn.onclick = () => {
  const elapsed = (Date.now() - turnStart) / 1000;

  const pace = applyPaceEffects(player, elapsed);
  player.tempAccuracyBonus = pace.accuracy;

  performMove(player, enemy, k);

  player.tempAccuracyBonus = 0;

  enemyTurn();
  turnStart = Date.now();
  updateUI();
};


  actions.appendChild(btn);
});

}

log("The fight begins.");
updateUI();
</script>

</body>
</html>
