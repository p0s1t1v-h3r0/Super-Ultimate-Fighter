<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Super Ultimate Fighter</title>
<style>
body {
  background:#111;
  color:#eee;
  font-family: monospace;
  padding:20px;
}
button {
  margin:4px;
  padding:8px;
  background:#222;
  color:#eee;
  border:1px solid #555;
  cursor:pointer;
}
button:hover { background:#333; }
#log {
  border:1px solid #444;
  padding:10px;
  height:300px;
  overflow-y:auto;
  background:#000;
}
.stat {
  margin-bottom:6px;
}
</style>
</head>
<body>

<h1>Super Ultimate Fighter (Prototype)</h1>

<div class="stat" id="status"></div>
<div class="stat" id="range"></div>
<div class="stat" id="stance"></div>
<div class="stat" id="timer"></div>

<h3>Actions</h3>
<div id="actions"></div>

<h3>Combat Log</h3>
<div id="log"></div>

<script>
// ---------------- CORE DATA ----------------

const RANGES = ["Kickboxing", "Boxing", "Clinch", "Ground"];
const STANCES = ["Orthodox", "Southpaw"];

function createFighter(name) {
  const fighter = {
    name,
    stance: Math.random() > 0.5 ? "Orthodox" : "Southpaw",
    range: "Boxing",

    stamina: 100,
    balance: 100,
    delay: 0,

    buffs: {},
    tempAccuracy: 0,
    knockedDown: false,

    limbs: {
      head: { skull: 100, face: 100 },
      torso: { chest: 100, liver: 100, solar: 100 },
      leftArm: { shoulder: 100, forearm: 100, hand: 100 },
      rightArm: { shoulder: 100, forearm: 100, hand: 100 },
      leftLeg: { thigh: 100, knee: 100, calf: 100 },
      rightLeg: { thigh: 100, knee: 100, calf: 100 }
    }
  };

  return fighter;
}

// ---------- GLOBAL STATE ----------
let player = createFighter("You");
let enemy = createFighter("Opponent");

let turnStart = Date.now();

// ---------- LOG ----------
const logEl = document.getElementById("log");

function log(text) {
  const p = document.createElement("p");
  p.textContent = text;
  logEl.appendChild(p);
  logEl.scrollTop = logEl.scrollHeight;
}

// ---------------- UTILS ----------------

// ---------- RANDOM ----------
function rand(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function randomBodyPart() {
  return rand(["head", "torso", "leftArm", "rightArm", "leftLeg", "rightLeg"]);
}

// ---------- BALANCE ----------
function applyBalanceDamage(defender, amount) {
  defender.balance -= amount;

  if (defender.balance <= 0 && !defender.knockedDown) {
    defender.knockedDown = true;
    defender.delay += 2;
    defender.balance = 30;
    log(`${defender.name} is knocked down!`);
  }
}

function legBalancePenalty(fighter) {
  const legs =
    fighter.limbs.leftLeg.thigh +
    fighter.limbs.rightLeg.thigh;

  if (legs < 120) return 2;
  if (legs < 80) return 4;
  return 0;
}

// ---------- LIMB PENALTIES ----------
function armAccuracyPenalty(fighter) {
  const arms =
    fighter.limbs.leftArm.forearm +
    fighter.limbs.rightArm.forearm;

  if (arms < 120) return -0.1;
  if (arms < 80) return -0.25;
  return 0;
}

function legEvasionPenalty(fighter) {
  const legs =
    fighter.limbs.leftLeg.calf +
    fighter.limbs.rightLeg.calf;

  if (legs < 120) return -0.1;
  if (legs < 80) return -0.25;
  return 0;
}

function headVisionPenalty(fighter) {
  const face = fighter.limbs.head.face;

  if (face < 60) return -0.15;
  if (face < 30) return -0.3;
  return 0;
}

// ---------- TELLS ----------
function painTell(fighter, part, sub) {
  if (fighter.buffs.pokerFace) return;

  const v = fighter.limbs[part][sub];

  if (v < 20) log(`${fighter.name} grimaces in pain.`);
  else if (v < 50) log(`${fighter.name} winces.`);
}

function breathingTell(fighter) {
  if (fighter.stamina < 20) {
    log(`${fighter.name} is gasping for air.`);
  } else if (fighter.stamina < 40) {
    log(`${fighter.name}'s breathing is heavy.`);
  }
}

// ---------- STANCE ----------
function isOrthodox(fighter) {
  return fighter.stance === "Orthodox";
}

function leadHand(fighter) {
  return isOrthodox(fighter) ? "leftArm" : "rightArm";
}

function rearHand(fighter) {
  return isOrthodox(fighter) ? "rightArm" : "leftArm";
}

// ---------- RANGE ----------
function rangeAllows(move, fighter) {
  if (!move.range) return true;
  return move.range.includes(fighter.range);
}

// ---------------- MOVE DEFINITIONS ----------------

const MOVES = {
  jab: {
    name: "Jab",
    stamina: 5,
    accuracy: 0.8,
    damage: 8,
    delay: 1,
    range: ["Boxing"],
    risk: "Low"
  },
  cross: {
    name: "Cross",
    stamina: 8,
    accuracy: 0.7,
    damage: 14,
    delay: 2,
    range: ["Boxing"],
    risk: "Medium"
  },
  heavyKick: {
    name: "Heavy Kick",
    stamina: 15,
    accuracy: 0.5,
    damage: 25,
    delay: 4,
    balanceRisk: 15,
    range: ["Kickboxing"],
    risk: "High"
  },
  clinch: {
    name: "Enter Clinch",
    stamina: 10,
    accuracy: 0.7,
    delay: 2,
    rangeChange: "Clinch"
  },
  focus: {
    name: "Sharpen Focus",
    stamina: 6,
    delay: 1,
    buff: { accuracy: 0.15, turns: 3 }
  },
  pokerFace: {
    name: "Poker Face",
    stamina: 5,
    delay: 1,
    buff: { conceal: true, turns: 3 }
  },
  dodge: {
    name: "Dodge (Buffered)",
    stamina: 6,
    accuracy: 0.6,
    delay: 1,
    defensive: true
  }
};

let bufferedDefense = null;

function bufferDefense(moveKey) {
  bufferedDefense = moveKey;
  log(`You prepare to ${MOVES[moveKey].name.toLowerCase()}.`);
}  

// ---------------- TURN LOGIC ----------------

let bufferedDefense = null;

function bufferDefense(moveKey) {
  bufferedDefense = moveKey;
  log(`You prepare to ${moves[moveKey].name.toLowerCase()}.`);
}

// ---------- PACE SYSTEM ----------
function applyPace(fighter, elapsed) {
  if (elapsed <= 10) {
    fighter.stamina -= 6;
    fighter.delay += 0;
    fighter.tempAccuracy = -0.1;
    log(`${fighter.name} moves fast and evasively.`);
  } else if (elapsed <= 20) {
    fighter.stamina -= 3;
    fighter.delay += 1;
    fighter.tempAccuracy = 0;
    log(`${fighter.name} keeps a steady pace.`);
  } else {
    fighter.stamina -= 1;
    fighter.delay += 2;
    fighter.tempAccuracy = 0.15;
    log(`${fighter.name} moves patiently and deliberately.`);
  }
}

// ---------- DEFENSIVE RESOLUTION ----------
function resolveDefense(attacker, defender) {
  if (!bufferedDefense) return false;

  const roll = Math.random();
  let success = false;

  if (bufferedDefense === "dodge") success = roll < 0.45;
  if (bufferedDefense === "slip") success = roll < 0.35;
  if (bufferedDefense === "parry") success = roll < 0.3;

  if (success) {
    log(`${defender.name} successfully ${bufferedDefense}s the attack!`);
    attacker.delay += 1;
  } else {
    log(`${defender.name} fails to ${bufferedDefense}.`);
    defender.delay += 1;
  }

  bufferedDefense = null;
  return success;
}

// ---------- MOVE RESOLUTION ----------
function performMove(attacker, defender, key) {
  const move = moves[key];
  if (!move) return;

  if (attacker.stamina <= 0) {
    log(`${attacker.name} is too exhausted to act.`);
    attacker.delay += 2;
    return;
  }

  // Apply stamina and delay
  attacker.stamina -= move.stamina || 2;
  attacker.delay += move.delay || 1;

  // Resolve defensive buffer
  if (resolveDefense(attacker, defender)) return;

  // Accuracy check
  let acc = (move.accuracy || 1) + (attacker.tempAccuracy || 0);
  acc = Math.max(0.1, acc);
  if (Math.random() > acc) {
    log(`${attacker.name}'s ${move.name} misses!`);
    attacker.delay += 1;
    return;
  }

  // Target limb
  const part = move.target || randomBodyPart();
  const limb = defender.limbs[part];
  const sub = Object.keys(limb)[Math.floor(Math.random() * Object.keys(limb).length)];

  // Calculate damage
  let actualDamage = move.damage || 0;
  limb[sub] -= actualDamage;
  if (limb[sub] < 0) limb[sub] = 0;

  log(`${attacker.name} lands a ${move.name} on ${defender.name}'s ${sub} (${part}) for ${actualDamage} damage!`);
  log(injuryDesc(limb[sub], sub));

  // Balance damage
  let balanceHit = move.balance || Math.floor(actualDamage / 2);
  balanceHit += legBalancePenalty(defender);
  applyBalanceDamage(defender, balanceHit);

  // Buffs
  if (move.buff) {
    for (const key in move.buff) {
      defender.buffs[key] = move.buff[key];
      setTimeout(() => { delete defender.buffs[key]; }, move.buff.turns * 1000);
    }
  }

  // Range changes
  if (move.enterRange) attacker.range = move.enterRange;
  if (move.exitRange) attacker.range = move.exitRange;

  // Tells
  painTell(defender, part, sub);
  breathingTell(defender);
}

// ---------- ENEMY TURN ----------
function enemyTurn() {
  if (enemy.delay > 0) {
    enemy.delay--;
    log(`${enemy.name} regains balance.`);
    return;
  }

  const keys = Object.keys(moves);
  const choice = keys[Math.floor(Math.random() * keys.length)];
  performMove(enemy, player, choice);
}

// ---------- PLAYER TURN ----------
function playerTurn(moveKey) {
  if (player.delay > 0) {
    player.delay--;
    log("You are recovering and cannot act.");
    return;
  }

  const elapsed = (Date.now() - turnStart) / 1000;
  applyPace(player, elapsed);

  performMove(player, enemy, moveKey);

  player.tempAccuracy = 0;
  turnStart = Date.now();
}


<!-- ---------------- UI ---------------- -->
<script>
function updateUI() {
  // Status
  document.getElementById("status").innerText =
    `You: ${staminaDesc(player.stamina)} | Balance feels ${player.balance > 50 ? "stable" : "shaky"}`;

  // Range
  document.getElementById("range").innerText =
    `Range: ${player.range}`;

  // Stance
  document.getElementById("stance").innerText =
    `Stance: ${player.stance}`;

  // Turn Timer
  const elapsed = Math.floor((Date.now() - turnStart) / 1000);
  document.getElementById("timer").innerText =
    `Turn Timer: ${elapsed}s`;

  // Actions
  const actions = document.getElementById("actions");
  actions.innerHTML = "";

  Object.keys(moves).forEach(k => {
    const move = moves[k];
    const btn = document.createElement("button");
    btn.innerText = move.name;

    if (move.defensive) {
      // Buffered defensive moves
      btn.onclick = () => {
        bufferDefense(k);
        updateUI();
      };
    } else {
      // Normal moves
      btn.onclick = () => {
        playerTurn(k);
        enemyTurn();
        updateUI();
      };
    }

    actions.appendChild(btn);
  });
}

// Optional: auto-update timer every 1 second
setInterval(() => {
  updateUI();
}, 1000);

// Start the fight
log("The fight begins.");
updateUI();
</script>
